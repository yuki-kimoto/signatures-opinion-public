<!DOCTYPE html>
<html>
  <head>
    <!-- meta -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<link rel="icon" type="image/x-icon" href="/signatures-opinion-public/images/giblog-logo.png">
<link rel="stylesheet" type="text/css" href="/signatures-opinion-public/css/common.css">

<title>Perl Subroutine Signatures Opinion Blog</title>
<meta name="description" content="Site description">
  </head>
  <body>
    <div class="container">
      <div class="header">
        <!-- header -->
<div class="main">
  <h1>
    <a href="/signatures-opinion-public/">Perl Subroutine Signatures Opinion Blog</a>
  </h1>
  <div>
    This site is an opinion blog about Perl Subroutine Signatures. Subroutine Signatures is plan to added to Perl in the near future. I have a very strong concern in the future of Perl, so I created an independent site about sub signatures. My name is Yuki Kimoto. I'm Perl Light User. I have no media power, community power, political power, and big company power. I just feel and talk about the heart of a weak perl user without a voice.
  </div>
</div>

      </div>
      <div class="main">
        <div class="content">
          <div class="entry">
  <div class="top">
    
  </div>
  <div class="middle">
    <div class="day">2019/12/18</div>
<h2><a href="/signatures-opinion-public/blog/20191218170414.html">Is the new grammar easy to google search?</a></h2>
<p>
  Is the new grammar of subroutine signatures easy to google search?
</p>
<p>
  One of the criticisms of Perl is that "it cannot search google because it has many symbols".
</p>
<p>
  Increasing the number of difficult-to-search symbols also increases the blame for Perl.
</p>
<h3>New symbol in subroutine signature</h3>
<p>
  In general, unlike function names, symbols are difficult to search for google.
</p>
<p>
  List new symbols in subroutine signature.
</p>
<table>
  <li>@</li>
  <li>%</li>
  <li>!$foo</li>
  <li>:$foo</li>
  <li>?$foo</li>
  <li>??$foo</li>
  <li>is</li>
  <li>isa</li>
  <li>where</li>
</table>
<p>
  Is it easy to understand when a beginner reads the code?
</p>
<p>
  Can one million Perl light users easily search for google?
</p>
<p>
  Put your hand on your chest and think sincerely and honestly.
</p>
<p>
  If you think Perl is part of the Perl community, it will fail.
</p>
<p>
  Perl is connected to business users and light users outside of Perl community.
</p>
<p>
  What is a good balance?
</p>


  </div>
  <div class="bottom">
    
  </div>
</div>

<div class="entry">
  <div class="top">
    
  </div>
  <div class="middle">
    <div class="day">2019/12/17</div>
<h2><a href="/signatures-opinion-public/blog/20191217163216.html">Are array and hash representations really needed?</a></h2>
<p>
  Are array and hash representations really needed?
</p>
<p>
  Currently, "@foo" is proposed as the array representation. "%foo" is proposed as the representation of the hash.
</p>
<pre>
# Array representation
sub (@foo) {
  
}
sub ($var, @foo) {
  
}

# Hash representation
sub (%foo) {
  
}

sub ($var, %foo) {
  
}
</pre>
<p>
  Are these always necessary?
</p>
<h3>Alternative representation using only scalar variables</h3>
<p>
  You can rewrite the above array and hash representation using only scalar variables if you need copy.
</p>
<pre>
# Array representation
sub ($foo) {
  my @foo = @$foo;
  
}
sub ($var, $foo) {
  my @foo = @$foo;
}

# Hash representation
sub ($foo) {
  my %foo = %$foo;
}
sub ($var, $foo) {
  my %foo = %$foo;
}
</pre>
<h3>In many languages, array and hash passed as a reference</h3>
<p>
  In many languages, array and hash passed as a reference.
</p>
<h4>JavaScript Function Definition</h4>
<p>
  At first, see JavaScript code. foo function definition.
</p>
<pre>
function foo (nums, opt) {
  
}
</pre>
<h4>Ruby Function Definition</h4>
<p>
  Next, see Ruby code of foo function definition.
</p>
<pre>
def foo (nums, opt)
  
end
</pre>
<h4>Python Function Definition</h4>
<p>
  Next, see Python code of foo function definition.
</p>
<pre>
def foo (nums, opt)
  
</pre>
<h4>PHP Function Definition</h4>
<p>
  Next, see PHP code of foo function definition.
</p>
<pre>
function foo ($nums, $opt) {

}
</pre>
<h4>Perl</h4>
<p>
  Subroutine signature of Perl is special.
</p>
<pre>
sub ($var, @foo) {
  
}

sub ($var, %foo) {
  
}
</pre>
<p>
  In fact, current Perl already have reference  different from past Perl.
</p>
<p>
  If it is limited to only scalar variables as arguments of subroutine signatures, alternative expressions are possible.
</p>
<h3>What is benefit of limited only scalar variables?</h3>
<p>
  What is benefit of limited only scalar variables?
</p>
<p>
  The biggest benefit is that the subroutine signature is very simple.
</p>
<p>
  Perl is already big and complex.
</p>
<p>
  External people feel that Perl is already difficult to read and complex.
</p>
<p>
  Therefore, the subroutine signature specification, which is easy to understand, gives good evaluation when viewed from outside.
</p>
<p>
  The Perl internal community may be frustrated.
</p>
<p>
  What is good balance?
</p>


  </div>
  <div class="bottom">
    
  </div>
</div>

<div class="entry">
  <div class="top">
    
  </div>
  <div class="middle">
    <div class="day">2019/12/16</div>
<h2><a href="/signatures-opinion-public/blog/20191216153849.html">Risk increased by checking the number of subroutine arguments</a></h2>
<p>
  The current subroutine signature specification checks the number of subroutine arguments.
</p>
<p>
  Many people think that this reduces the mistake of checking for incorrect argument count.
</p>
<pre>
sub foo ($args1, $args2) {
  
}

# Exception occur for argument count is difference
foo(1, 2, 3);
</pre>
<p>
  On the other hand, there is actually risks of increasing by checking the argument count.
</p>
<h3>Unexpected exception due to later increase of subroutine arguments</h3>
<p>
  I yet see the discussion that unexpected exception due to later increase of subroutine arguments.
</p>
<p>
  I will explain this with a sample.
</p>
<p>
  First, a subroutine is defined with one argument.
</p>
<pre>
sub foo ($num) {
  
}
</pre>
<p>
  User use this subroutine in many place.
</p>
<pre>
foo(1);

foo(2);

foo(3);
</pre>
<p>
  After a while, you want to pass options to this function and change the code to:
</p>
<pre>
sub foo ($num, $opt) {
  $opt //= {};
}
</pre>
<p>
  The user believes it is the same as the following change:
</p>
<pre>
# Before
sub foo {
  my ($num) = @_;
}

# After
sub foo {
  my ($num, $opt) = @_;
}
</pre>
<p>
  Long-time Perl users know that this change doesn't break the source code and this is how it works.
</p>
<p>
  This change is a long practice for Perl users and has been going on for a long time.
</p>
<p>
  On the other hand, checking the number of arguments in a subroutine signature yields different results.
</p>
<pre>
# Unexpected exception
foo(1);

# Unexpected exception
foo(2);

# Unexpected exception
foo(3);
</pre>
<p>
  "The program is broken. An exception is thrown in an unexpected place!"
</p>
<p>
  There is a risk of adding unexpected bugs by checking the number of subroutine arguments.
</p>
<h3>Should I use the default value?</h3>
<p>
  Such an answer seems to be returned to the above problem.
</p>
<p>
  "Should I use the default value?"
</p>
<pre>
sub foo ($num, $opt = {}) {

}
</pre>
<p>
  This is work well in fact.
</p>
<p>
  What is the problem I feel about this?
</p>
<p>
  This is unintended behavior for users who have been using Perl for a long time.
</p>
<p>
  Perl users generally do not expect Perl to be constrained.
</p>
<p>
  Perl users expect that there are no constraints by default.
</p>
<p>
  The presence of constraints by calling the module is the user's choice, but the subroutine signature is a core feature.
</p>
<p>
  If Perl user write the following for long-standing habits, code is broken. 
</p>
<pre>
sub foo ($num, $opt) {
  $opt //= {};
}
</pre>
<p>
  "Oh, in production code, an unexpected exception has occurred! Subroutine signature increases unexpected risk!"
</p>
<p>
  Are we just thinking that adding constraints reduces the risk of mistakes?
</p>
<p>
  Want to add to the discussion that an unexpected exception can break your production code?
</p>
<p>
  Do Perl subroutine signatures require a constraints of number of arguments? 
</p>
<p>
  Isn't it essential?
</p>
<p>
  Is checking the number of subroutines compatible with Perl's dynamic mechanism?
</p>


  </div>
  <div class="bottom">
    
  </div>
</div>

<div class="entry">
  <div class="top">
    
  </div>
  <div class="middle">
    <div class="day">2019/03/19</div>
<h2><a href="/signatures-opinion-public/blog/20190319121234.html">Why we want subroutine signatures?</a></h2>
<p>
  As a first starting point, why do we want a subroutine signature?
</p>
<p>
  What is missing in Perl?
</p>
<h4>JavaScript Function Definition</h4>
<p>
  At first, see JavaScript code. foo function definition.
</p>
<pre>
function foo (args1, args2) {
  
}
</pre>
<h4>Ruby Function Definition</h4>
<p>
  Next, see Ruby code of foo function definition.
</p>
<pre>
def foo (args1, args2)
  
end
</pre>
<h4>Python Function Definition</h4>
<p>
  Next, see Python code of foo function definition.
</p>
<pre>
def foo (args1, args2)
  
</pre>
<h4>PHP Function Definition</h4>
<p>
  Next, see PHP code of foo function definition.
</p>
<pre>
function foo ($args1, $args2) {

}
</pre>
<h4>Perl Function Definition</h4>
<p>
  Last, see Perl code of foo function definition.
</p>
<pre>
sub foo {
  my ($args1, $args2) = @_;
}
</pre>
<p>
  Why Perl don't write the other languages?
</p>
<h3>Argument definition is very generally expression</h3>
<p>
  Argument definition is very generally expression in other all of modern programming languages.
</p>
<p>
  People say
</p>
<p>
  "What is @_?"
</p>
<p>
  "Perl have many symbols."
</p>
<p>
  "Perl is a old and dirty language"
</p>
<p>
  <b>We need subroutine signatures to make Perl argument definitions fit into a very general expression.</b>
</p>
<p>
  This is most biggest reason.
</p>
<p>
  Subroutine signatures remove one of the criticisms "Perl is unreadable".
</p>


  </div>
  <div class="bottom">
    
  </div>
</div>

<div class="before-days"><a href="/signatures-opinion-public/list.html">Before Days</a></div>
        </div>
        <div class="side">
          <!-- side -->
<div class="side-list">
  <div class="side-list-title">
    Content
  </div>
  <ul>
    <li><a href="/signatures-opinion-public/list.html">Entries</a></li>
    <li><a href="/signatures-opinion-public/blog/20190319121234.html">Why we want subroutine signatures?</a></li>
    <li><a href="/signatures-opinion-public/blog/20191216153849.html">Risk increased by checking the number of subroutine arguments</a><span style="color:gold">★★★</span></li>
    <li><a href="/signatures-opinion-public/blog/20191217163216.html">Are array and hash representations really needed?</a><span style="color:gold">★</span></li>
    <li><a href="/signatures-opinion-public/blog/20191218170414.html">Is the new grammar easy to google search?</a><span style="color:gold">★</span></li>
  </ul>
</div>

        </div>
      </div>
      <div class="footer">
        <!-- footer -->
<a href="https://github.com/yuki-kimoto/giblog">Giblog</a>

      </div>
    </div>
  </body>
</html>
