<!DOCTYPE html>
<html>
  <head>
    <!-- meta -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<link rel="icon" type="image/x-icon" href="/signatures-opinion-public/images/giblog-logo.png">
<link rel="stylesheet" type="text/css" href="/signatures-opinion-public/css/common.css">

<title>Perl Subroutine Signatures Opinion Blog</title>
<meta name="description" content="Site description">
  </head>
  <body>
    <div class="container">
      <div class="header">
        <!-- header -->
<div class="main">
  <h1>
    <a href="/signatures-opinion-public/">Perl Subroutine Signatures Opinion Blog</a>
  </h1>
  <div>
    This site is an opinion blog about Perl Subroutine Signatures. Subroutine Signatures is plan to added to Perl in the near future. I have a very strong concern in the future of Perl, so I created an independent site about sub signatures. My name is Yuki Kimoto. I'm Perl Light User. I have no media power, community power, political power, and big company power. I just feel and talk about the heart of a weak perl user without a voice.
  </div>
</div>

      </div>
      <div class="main">
        <div class="content">
          <div class="entry">
  <div class="top">
    
  </div>
  <div class="middle">
    <div class="day">2019/12/24</div>
<h2><a href="/signatures-opinion-public/blog/20191224114859.html">Default value expression</a></h2>
<p>
  In first proposal of subroutine signatures, default value is the following.
</p>
<pre>
sub func($foo //= 0, $bar ||= 0) {
  
}
</pre>
<p>
  I think this can use only "=" as same as many ohter languages. and "||" is in body if needed.
</p>
<pre>
sub func($foo = 0, $bar) {
  $bar ||= 0;
}
</pre>
<p>
  This expression is general in other languages.
</p>
<h4>PHP</h4>
<pre>
function makecoffee($type = "cappuccino")
{
    return "Making a cup of $type.\n";
}
</pre>
<h4>Python</h4>
<pre>
def func_default(arg1, arg2='default_x', arg3='default_y'):
    print(arg1)
    print(arg2)
    print(arg3)
</pre>
<h4>Ruby</h4>
<pre>
def printHello(msg="No msg", name="No name")
  print(msg + "," + name + "¥n")
end
</pre>


  </div>
  <div class="bottom">
    
  </div>
</div>

<div class="entry">
  <div class="top">
    
  </div>
  <div class="middle">
    <div class="day">2019/12/23</div>
<h2><a href="/signatures-opinion-public/blog/20191223153633.html">Type Constraints using Type::Tiny and attribute handler</a></h2>
<p>
  If you can perform type checking with an attribute handler and <a href="https://metacpan.org/pod/Type::Tiny">Type::Tiny</a>, Perl will be more attractive.
</p>
<p>
  For example.
</p>
<pre>
use Type::Tiny::Signatures;

sub foo ($str : Str, $num : Int) {
  
}
</pre>
<h3>What is attribute handler?</h3>
<p>
  The attribute handler is a function that can handle the attribute setting of subroutines and variables from Perl 5.6.
</p>
<pre>
#!perl -w
use strict;

sub MODIFY_CODE_ATTRIBUTES{
  my($class, $code_ref, $attr_name) = @_;
  Dump($code_ref);
}

# Subroutine attribute
sub foo : MyAttr {

}
</pre>
<p>
  Perl already has a syntax called attributes.
</p>
<pre>
sub foo : attribute
</pre>
<h3>Attribute for arguments of subroutine signatures</h3>
<p>
  We are fortunate.
</p>
<p>
  Aattributes of subroutine argument are not yet implemented.
</p>
<p>
  We can implement the use of subroutine attributes without worrying about the past.
</p>
<p>
  It would be nice to be able to check arguments by combining a subroutine argument attribute handler with <a href="https://metacpan.org/pod/Type::Tiny">Type::Tiny</a>.
</p>
<pre>
use Type::Tiny::Signatures;

sub foo ($str : Str, $num : Int) {
  
}
</pre>
<h3>Perl core is all dynamic, and you can add listrictions by module</h3>
<p>
  We have known for 30 years that all Perl core is dynamic.
</p>
<p>
  Perl has no restrictions by default.
</p>
<p>
  On the other hand, you can incorporate constraints by using modules.
</p>
<p>
  For example,
</p>
<p>
  <a href="https://metacpan.org/pod/fields">fields</a> modules for field listrictions.
</p>
<p>
  <a href="https://metacpan.org/pod/Hash::Util">Hash::Util::lock_keys</a> for hash key listrictions.
</p>
<p>
  Sure, <a href="https://metacpan.org/pod/Type::Tiny">Type::Tiny</a> for type constraints.
</p>
<p>
  This is 30 years of Perl convention.
</p>
<p>
  If signatures is dynamic and, add listrictions by module and attribute handler,
</p>
<p>
  We are likely to be able to work with the old and the new and solve the Perl community's dissatisfaction.
</p>
<p>
  I hope that older users who have enjoyed the dynamic types of Perl can collaborate with the Perl community who wanted to do type checking.
</p>
<p>
  I suggest an implementation where <a href="https://metacpan.org/pod/Type::Tiny">Type::Tiny</a> works correctly with subroutine signatures.
</p>


  </div>
  <div class="bottom">
    
  </div>
</div>

<div class="entry">
  <div class="top">
    
  </div>
  <div class="middle">
    <div class="day">2019/12/20</div>
<h2><a href="/signatures-opinion-public/blog/20191220163642.html">The way that CPAN authors use subroutine signatures in natural</a></h2>
<p>
  Perl users contains CPAN authors, not only application users who use the new version of Perl.
</p>
<p>
  Generally, CPAN authors use Perl old grammar to support older versions of Perl.
</p>
<p>
  Most CPAN modules support Perl 5.8+, and Some modules support Perl 5.10+ and 5.12+.
</p>
<h3>CPAN authors also want to use subroutine signatures</h3>
<p>
  Perl's new feature is for the new Perl, but when it comes to subroutine signatures, CPAN Author also maybe wants to use it.
</p>
<p>
  If CPAN authors can use subroutine signatures, both application code and CPAN module code can be written in one source.
</p>
<p>
  I think new features should work with the new Perl, but I'm happy that only the subroutine signature feature can be backported.
</p>
<p>
  Wouldn't it be nice if you could use subroutine signatures with tens of thousands of CPAN modules?
</p>
<p>
  But is there such a way?
</p>
<h3>Use signatures.pm if the perl version is lower than subroutine signatures</h3>
<p>
  Use signatures.pm if the perl version is lower than Perl which support subroutine signatures.
</p>
<p>
  I write the code. CPAN author can use signatures.pm instead of core subroutine signatures.
</p>
<p>
  This code use SigImport. SigImport export signatures.pm features to Foo.
</p>
<pre>
package Foo;

use strict;
use warnings;
use utf8;
use FindBin;

use lib "$FindBin::Bin";

use SigImport;

# Subroutine signatures imported from signatures.pm
sub func($foo) {
  return $foo;
}

package main;

print Foo::func(1, 2);
</pre>
<p>
  SigImport. This contains some signatures.pm fix.
</p>
<pre>
package SigImport;

BEGIN {
  require signatures;
}

BEGIN {
  no warnings 'redefine';
  sub signatures::import {
    my ($class, $caller) = @_;
    $caller ||= caller();
    $pkgs{$caller} = $class-&gt;setup_for($caller);
    return;
  }
}

sub import {
  my $caller = caller;
  
   
  #if ($] &gt;= 5.034001) {
  #  feature-&gt;import('signatures');
  #}
  #else {
    signatures-&gt;import($caller);
  #}
}

1;
</pre>
<p>
  This code work well. Swich signatures features by Perl version.
</p>
<p>
  In this way, a more several things is needed.
</p>
<h4>the number of arguments in the subroutine signature is not checked by default</h4>
<p>
  the number of arguments in the subroutine signature is not checked by default.
</p>
<p>
  See also the following entry.
</p>
<p>
  <a href="/signatures-opinion-public/blog/20191216153849.html">Risk increased by checking the number of subroutine arguments</a>
</p>
<h4>signatures.pm is bandled to Perl core</h4>
<p>
  If signatures.pm is bandled to Perl core, we can write the following in Makefile.PL
</p>
<pre>
    PREREQ_PM =&gt; {
      'signatures.pm' =&gt; 0.15,
    },
</pre>
<p>
  CPAN authores can switch signature.pm to core subroutine signatures.
</p>
<p>
  Wouldn't it be nice if you could fix the past in a subroutine signature?
</p>


  </div>
  <div class="bottom">
    
  </div>
</div>

<div class="entry">
  <div class="top">
    
  </div>
  <div class="middle">
    <div class="day">2019/12/18</div>
<h2><a href="/signatures-opinion-public/blog/20191218170414.html">Is the new grammar easy to google search?</a></h2>
<p>
  Is the new grammar of subroutine signatures easy to google search?
</p>
<p>
  One of the criticisms of Perl is that "it cannot search google because it has many symbols".
</p>
<p>
  Increasing the number of difficult-to-search symbols also increases the blame for Perl.
</p>
<h3>New symbol in subroutine signature</h3>
<p>
  In general, unlike function names, symbols are difficult to search for google.
</p>
<p>
  List new symbols in the proposal of subroutine signature.
</p>
<table>
  <li>@</li>
  <li>%</li>
  <li>!$foo</li>
  <li>:$foo</li>
  <li>?$foo</li>
  <li>??$foo</li>
  <li>is</li>
  <li>isa</li>
  <li>where</li>
</table>
<p>
  Is it easy to understand when a beginner reads the code?
</p>
<p>
  Can one million Perl light users easily search for google?
</p>
<p>
  Put your hand on your chest and think sincerely and honestly.
</p>
<p>
  If you think Perl is part of the Perl community, it will take mistake.
</p>
<p>
  Perl is also connected to business users and light users outside of Perl community.
</p>
<p>
  What is a good balance?
</p>


  </div>
  <div class="bottom">
    
  </div>
</div>

<div class="entry">
  <div class="top">
    
  </div>
  <div class="middle">
    <div class="day">2019/12/17</div>
<h2><a href="/signatures-opinion-public/blog/20191217163216.html">Are array and hash representations really needed?</a></h2>
<p>
  Are array and hash representations really needed?
</p>
<p>
  Currently, "@foo" is proposed as the array representation. "%foo" is proposed as the representation of the hash.
</p>
<pre>
# Array representation
sub (@foo) {
  
}
sub ($var, @foo) {
  
}

# Hash representation
sub (%foo) {
  
}

sub ($var, %foo) {
  
}
</pre>
<p>
  Are these always necessary?
</p>
<h3>Alternative representation using only scalar variables</h3>
<p>
  You can rewrite the above array and hash representation using only scalar variables if you need copy.
</p>
<pre>
# Array representation
sub ($foo) {
  my @foo = @$foo;
  
}
sub ($var, $foo) {
  my @foo = @$foo;
}

# Hash representation
sub ($foo) {
  my %foo = %$foo;
}
sub ($var, $foo) {
  my %foo = %$foo;
}
</pre>
<h3>In many languages, array and hash passed as a reference</h3>
<p>
  In many languages, array and hash passed as a reference.
</p>
<h4>JavaScript Function Definition</h4>
<p>
  At first, see JavaScript code. foo function definition.
</p>
<pre>
function foo (nums, opt) {
  
}
</pre>
<h4>Ruby Function Definition</h4>
<p>
  Next, see Ruby code of foo function definition.
</p>
<pre>
def foo (nums, opt)
  
end
</pre>
<h4>Python Function Definition</h4>
<p>
  Next, see Python code of foo function definition.
</p>
<pre>
def foo (nums, opt)
  
</pre>
<h4>PHP Function Definition</h4>
<p>
  Next, see PHP code of foo function definition.
</p>
<pre>
function foo ($nums, $opt) {

}
</pre>
<h4>Perl</h4>
<p>
  Subroutine signature of Perl is special.
</p>
<pre>
sub ($var, @foo) {
  
}

sub ($var, %foo) {
  
}
</pre>
<p>
  In fact, current Perl already have reference  different from past Perl.
</p>
<p>
  If it is limited to only scalar variables as arguments of subroutine signatures, alternative expressions are possible.
</p>
<h3>What is benefit of limited only scalar variables?</h3>
<p>
  What is benefit of limited only scalar variables?
</p>
<p>
  The biggest benefit is that the subroutine signature is very simple.
</p>
<p>
  Perl is already big and complex.
</p>
<p>
  External people feel that Perl is already difficult to read and complex.
</p>
<p>
  Therefore, the subroutine signature specification, which is easy to understand, gives good evaluation when viewed from outside.
</p>
<p>
  The Perl internal community may be frustrated.
</p>
<p>
  What is good balance?
</p>


  </div>
  <div class="bottom">
    
  </div>
</div>

<div class="entry">
  <div class="top">
    
  </div>
  <div class="middle">
    <div class="day">2019/12/16</div>
<h2><a href="/signatures-opinion-public/blog/20191216153849.html">Risk increased by checking the number of subroutine arguments</a></h2>
<p>
  The current subroutine signature specification checks the number of subroutine arguments.
</p>
<p>
  Many people think that this reduces the mistake of checking for incorrect argument count.
</p>
<pre>
sub foo ($args1, $args2) {
  
}

# Exception occur for argument count is difference
foo(1, 2, 3);
</pre>
<p>
  On the other hand, there is actually risks of increasing by checking the argument count.
</p>
<h3>Unexpected exception due to later increase of subroutine arguments</h3>
<p>
  I yet see the discussion that unexpected exception due to later increase of subroutine arguments.
</p>
<p>
  I will explain this with a sample.
</p>
<p>
  First, a subroutine is defined with one argument.
</p>
<pre>
sub foo ($num) {
  
}
</pre>
<p>
  User use this subroutine in many place.
</p>
<pre>
foo(1);

foo(2);

foo(3);
</pre>
<p>
  After a while, you want to pass options to this function and change the code to:
</p>
<pre>
sub foo ($num, $opt) {
  $opt //= {};
}
</pre>
<p>
  The user believes it is the same as the following change:
</p>
<pre>
# Before
sub foo {
  my ($num) = @_;
}

# After
sub foo {
  my ($num, $opt) = @_;
}
</pre>
<p>
  Long-time Perl users know that this change doesn't break the source code and this is how it works.
</p>
<p>
  This change is a long practice for Perl users and has been going on for a long time.
</p>
<p>
  On the other hand, checking the number of arguments in a subroutine signature yields different results.
</p>
<pre>
# Unexpected exception
foo(1);

# Unexpected exception
foo(2);

# Unexpected exception
foo(3);
</pre>
<p>
  "The program is broken. An exception is thrown in an unexpected place!"
</p>
<p>
  There is a risk of adding unexpected bugs by checking the number of subroutine arguments.
</p>
<h3>Should I use the default value?</h3>
<p>
  Such an answer seems to be returned to the above problem.
</p>
<p>
  "Should I use the default value?"
</p>
<pre>
sub foo ($num, $opt = {}) {

}
</pre>
<p>
  This is work well in fact.
</p>
<p>
  What is the problem I feel about this?
</p>
<p>
  This is unintended behavior for users who have been using Perl for a long time.
</p>
<p>
  Perl users generally do not expect Perl to be constrained.
</p>
<p>
  Perl users expect that there are no constraints by default.
</p>
<p>
  The presence of constraints by calling the module is the user's choice, but the subroutine signature is a core feature.
</p>
<p>
  If Perl user write the following for long-standing habits, code is broken. 
</p>
<pre>
sub foo ($num, $opt) {
  $opt //= {};
}
</pre>
<p>
  "Oh, in production code, an unexpected exception has occurred! Subroutine signature increases unexpected risk!"
</p>
<p>
  Are we just thinking that adding constraints reduces the risk of mistakes?
</p>
<p>
  Want to add to the discussion that an unexpected exception can break your production code?
</p>
<p>
  Do Perl subroutine signatures require a constraints of number of arguments? 
</p>
<p>
  Isn't it essential?
</p>
<p>
  Is checking the number of subroutines compatible with Perl's dynamic mechanism?
</p>


  </div>
  <div class="bottom">
    
  </div>
</div>

<div class="entry">
  <div class="top">
    
  </div>
  <div class="middle">
    <div class="day">2019/03/19</div>
<h2><a href="/signatures-opinion-public/blog/20190319121234.html">Why we want subroutine signatures?</a></h2>
<p>
  As a first starting point, why do we want a subroutine signature?
</p>
<p>
  What is missing in Perl?
</p>
<h4>JavaScript Function Definition</h4>
<p>
  At first, see JavaScript code. foo function definition.
</p>
<pre>
function foo (args1, args2) {
  
}
</pre>
<h4>Ruby Function Definition</h4>
<p>
  Next, see Ruby code of foo function definition.
</p>
<pre>
def foo (args1, args2)
  
end
</pre>
<h4>Python Function Definition</h4>
<p>
  Next, see Python code of foo function definition.
</p>
<pre>
def foo (args1, args2)
  
</pre>
<h4>PHP Function Definition</h4>
<p>
  Next, see PHP code of foo function definition.
</p>
<pre>
function foo ($args1, $args2) {

}
</pre>
<h4>Perl Function Definition</h4>
<p>
  Last, see Perl code of foo function definition.
</p>
<pre>
sub foo {
  my ($args1, $args2) = @_;
}
</pre>
<p>
  Why Perl don't write the other languages?
</p>
<h3>Argument definition is very generally expression</h3>
<p>
  Argument definition is very generally expression in other all of modern programming languages.
</p>
<p>
  People say
</p>
<p>
  "What is @_?"
</p>
<p>
  "Perl have many symbols."
</p>
<p>
  "Perl is a old and dirty language"
</p>
<p>
  <b>We need subroutine signatures to make Perl argument definitions fit into a very general expression.</b>
</p>
<p>
  This is most biggest reason.
</p>
<p>
  Subroutine signatures remove one of the criticisms "Perl is unreadable".
</p>


  </div>
  <div class="bottom">
    
  </div>
</div>

<div class="before-days"><a href="/signatures-opinion-public/list.html">Before Days</a></div>
        </div>
        <div class="side">
          <!-- side -->
<div class="side-list">
  <div class="side-list-title">
    Content
  </div>
  <ul>
    <li><a href="/signatures-opinion-public/list.html">Entries</a></li>
    <li><a href="/signatures-opinion-public/blog/20190319121234.html">Why we want subroutine signatures?</a></li>
    <li><a href="/signatures-opinion-public/blog/20191216153849.html">Risk increased by checking the number of subroutine arguments</a><span style="color:gold">★★★</span></li>
    <li><a href="/signatures-opinion-public/blog/20191217163216.html">Are array and hash representations really needed?</a><span style="color:gold">★</span></li>
    <li><a href="/signatures-opinion-public/blog/20191218170414.html">Is the new grammar easy to google search?</a><span style="color:gold">★</span></li>
    <li><a href="/signatures-opinion-public/blog/20191220163642.html">The way that CPAN authors use subroutine signatures in natural</a><span style="color:gold">★★★</span></li>
    <li><a href="/signatures-opinion-public/blog/20191223153633.html">Type Constraints using Type::Tiny and attribute handler</a><span style="color:gold">★★</span></li>
  </ul>
</div>

        </div>
      </div>
      <div class="footer">
        <!-- footer -->
<a href="https://github.com/yuki-kimoto/giblog">Giblog</a>

      </div>
    </div>
  </body>
</html>
